using System.Collections.Immutable;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using Sbroenne.ExcelMcp.Generators.Common;

namespace Sbroenne.ExcelMcp.Generators.Cli;

/// <summary>
/// Generates CLI Settings classes with Spectre.Console attributes
/// from Core command interfaces marked with [ServiceCategory].
/// </summary>
[Generator]
public class CliSettingsGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Find all interfaces with [ServiceCategory] attribute
        var interfaceDeclarations = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (s, _) => SyntaxHelper.IsInterfaceWithAttributes(s),
                transform: static (ctx, _) => SyntaxHelper.GetServiceInterfaceOrNull(ctx))
            .Where(static m => m is not null);

        // Combine with compilation
        var compilationAndInterfaces = context.CompilationProvider.Combine(interfaceDeclarations.Collect());

        // Generate source
        context.RegisterSourceOutput(compilationAndInterfaces,
            static (spc, source) => Execute(source.Left, source.Right!, spc));
    }

    private static void Execute(Compilation compilation, ImmutableArray<InterfaceDeclarationSyntax?> interfaces, SourceProductionContext context)
    {
        if (interfaces.IsDefaultOrEmpty)
            return;

        var distinctInterfaces = interfaces
            .Where(i => i is not null)
            .Cast<InterfaceDeclarationSyntax>()
            .Distinct()
            .ToList();

        if (distinctInterfaces.Count == 0)
            return;

        foreach (var interfaceDecl in distinctInterfaces)
        {
            var model = compilation.GetSemanticModel(interfaceDecl.SyntaxTree);
            var interfaceSymbol = model.GetDeclaredSymbol(interfaceDecl) as INamedTypeSymbol;

            if (interfaceSymbol is null)
                continue;

            var info = ServiceInfoExtractor.ExtractServiceInfo(interfaceSymbol);
            if (info is null)
                continue;

            // Generate CLI Settings for this category
            var settingsCode = GenerateCliSettings(info);
            context.AddSource($"CliSettings.{info.CategoryPascal}.g.cs", SourceText.From(settingsCode, Encoding.UTF8));
        }
    }

    private static string GenerateCliSettings(ServiceInfo info)
    {
        var sb = new StringBuilder();

        sb.AppendLine("// <auto-generated />");
        sb.AppendLine("#nullable enable");
        sb.AppendLine("#pragma warning disable CS1591 // Missing XML comment");
        sb.AppendLine();
        sb.AppendLine("using System.ComponentModel;");
        sb.AppendLine("using Spectre.Console.Cli;");
        sb.AppendLine();
        sb.AppendLine("namespace Sbroenne.ExcelMcp.CLI.Generated;");
        sb.AppendLine();
        sb.AppendLine("/// <summary>");
        sb.AppendLine($"/// Generated CLI settings for {info.CategoryPascal} commands.");
        sb.AppendLine("/// </summary>");
        sb.AppendLine($"public sealed class {info.CategoryPascal}Settings : CommandSettings");
        sb.AppendLine("{");

        // Action argument (always first)
        sb.AppendLine("    [CommandArgument(0, \"<ACTION>\")]");
        sb.AppendLine("    [Description(\"The action to perform\")]");
        sb.AppendLine("    public string Action { get; init; } = string.Empty;");
        sb.AppendLine();

        // Session ID (always required for session-based tools)
        if (!info.NoSession)
        {
            sb.AppendLine("    [CommandOption(\"-s|--session <SESSION>\")]");
            sb.AppendLine("    [Description(\"Session ID from 'session open' command\")]");
            sb.AppendLine("    public string SessionId { get; init; } = string.Empty;");
            sb.AppendLine();
        }

        // Collect unique exposed parameters across all methods
        var allParams = ServiceInfoExtractor.GetAllExposedParameters(info);
        foreach (var p in allParams)
        {
            var optionName = StringHelper.ToKebabCase(p.Name);
            var description = p.Description ?? StringHelper.GetParameterDescription(p.Name);
            var valuePlaceholder = p.Name.ToUpperInvariant();

            sb.AppendLine($"    [CommandOption(\"--{optionName} <{valuePlaceholder}>\")]");
            sb.AppendLine($"    [Description(\"{EscapeString(description)}\")]");
            sb.AppendLine($"    public {p.TypeName} {StringHelper.ToPascalCase(p.Name)} {{ get; init; }}");
            sb.AppendLine();
        }

        sb.AppendLine("}");

        return sb.ToString();
    }

    private static string EscapeString(string value)
    {
        return value.Replace("\"", "\\\"").Replace("\n", " ").Replace("\r", "");
    }
}
