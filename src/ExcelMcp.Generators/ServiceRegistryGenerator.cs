using System.Collections.Immutable;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using Sbroenne.ExcelMcp.Generators.Common;

namespace Sbroenne.ExcelMcp.Generators;

/// <summary>
/// Generates ServiceRegistry constants and DTOs from Core command interfaces
/// marked with [ServiceCategory] attribute.
/// </summary>
[Generator]
public class ServiceRegistryGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Find all interfaces with [ServiceCategory] attribute
        var interfaceDeclarations = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (s, _) => SyntaxHelper.IsInterfaceWithAttributes(s),
                transform: static (ctx, _) => SyntaxHelper.GetServiceInterfaceOrNull(ctx))
            .Where(static m => m is not null);

        // Combine with compilation
        var compilationAndInterfaces = context.CompilationProvider.Combine(interfaceDeclarations.Collect());

        // Generate source
        context.RegisterSourceOutput(compilationAndInterfaces,
            static (spc, source) => Execute(source.Left, source.Right!, spc));
    }

    private static void Execute(Compilation compilation, ImmutableArray<InterfaceDeclarationSyntax?> interfaces, SourceProductionContext context)
    {
        if (interfaces.IsDefaultOrEmpty)
            return;

        var distinctInterfaces = interfaces
            .Where(i => i is not null)
            .Cast<InterfaceDeclarationSyntax>()
            .Distinct()
            .ToList();

        if (distinctInterfaces.Count == 0)
            return;

        foreach (var interfaceDecl in distinctInterfaces)
        {
            var model = compilation.GetSemanticModel(interfaceDecl.SyntaxTree);
            var interfaceSymbol = model.GetDeclaredSymbol(interfaceDecl) as INamedTypeSymbol;

            if (interfaceSymbol is null)
                continue;

            // Use shared extractor
            var info = ServiceInfoExtractor.ExtractServiceInfo(interfaceSymbol);
            if (info is null)
                continue;

            // Generate ServiceRegistry partial for this category
            var registryCode = GenerateServiceRegistry(info);
            context.AddSource($"ServiceRegistry.{info.CategoryPascal}.g.cs", SourceText.From(registryCode, Encoding.UTF8));

            // Generate comparison file for validation (existing vs generated)
            var comparisonCode = GenerateComparisonFile(info);
            context.AddSource($"Comparison.{info.CategoryPascal}.g.cs", SourceText.From(comparisonCode, Encoding.UTF8));
        }
    }

    // =====================================================
    // Code Generation Methods (local to this generator)
    // =====================================================

    private static string GenerateServiceRegistry(ServiceInfo info)
    {
        var sb = new StringBuilder();

        sb.AppendLine("// <auto-generated />");;
        sb.AppendLine("#nullable enable");
        sb.AppendLine("#pragma warning disable CS1591 // Missing XML comment for publicly visible type or member");
        sb.AppendLine();
        sb.AppendLine("namespace Sbroenne.ExcelMcp.Generated;");
        sb.AppendLine();

        // Generate the Action enum
        sb.AppendLine("/// <summary>");
        sb.AppendLine($"/// Generated action enum for {info.Category} operations.");
        sb.AppendLine("/// </summary>");
        sb.AppendLine($"public enum {info.CategoryPascal}Action");
        sb.AppendLine("{");
        for (int i = 0; i < info.Methods.Count; i++)
        {
            var method = info.Methods[i];
            var comma = i < info.Methods.Count - 1 ? "," : "";
            sb.AppendLine($"    {method.MethodName}{comma}");
        }
        sb.AppendLine("}");
        sb.AppendLine();

        sb.AppendLine("/// <summary>");
        sb.AppendLine($"/// Generated service registry for {info.Category} operations.");
        sb.AppendLine("/// </summary>");
        sb.AppendLine($"public static partial class ServiceRegistry");
        sb.AppendLine("{");
        sb.AppendLine($"    public static partial class {info.CategoryPascal}");
        sb.AppendLine("    {");
        sb.AppendLine($"        public const string Category = \"{info.Category}\";");
        sb.AppendLine($"        public const string McpToolName = \"{info.McpToolName}\";");
        sb.AppendLine($"        public const bool RequiresSession = {(info.NoSession ? "false" : "true")};");
        sb.AppendLine();

        // Generate action constants
        sb.AppendLine("        // Action constants");
        foreach (var method in info.Methods)
        {
            sb.AppendLine($"        public const string {method.MethodName}Action = \"{method.ActionName}\";");
        }
        sb.AppendLine();

        // Generate full command strings
        sb.AppendLine("        // Full command strings (category.action)");
        foreach (var method in info.Methods)
        {
            sb.AppendLine($"        public const string {method.MethodName}Command = \"{info.Category}.{method.ActionName}\";");
        }
        sb.AppendLine();

        // Generate ValidActions array for CLI help/validation
        sb.AppendLine("        /// <summary>");
        sb.AppendLine("        /// All valid action strings for this category.");
        sb.AppendLine("        /// </summary>");
        var actionList = string.Join(", ", info.Methods.Select(m => $"\"{m.ActionName}\""));
        sb.AppendLine($"        public static readonly string[] ValidActions = [{actionList}];");
        sb.AppendLine();

        // Generate TryParseAction method for this category
        sb.AppendLine("        /// <summary>");
        sb.AppendLine("        /// Parses a kebab-case action string to the strongly-typed enum.");
        sb.AppendLine("        /// </summary>");
        sb.AppendLine($"        public static bool TryParseAction(string actionString, out {info.CategoryPascal}Action action)");
        sb.AppendLine("        {");
        sb.AppendLine("            action = default;");
        sb.AppendLine("            return actionString switch");
        sb.AppendLine("            {");
        foreach (var method in info.Methods)
        {
            sb.AppendLine($"                \"{method.ActionName}\" => SetAndReturn(out action, {info.CategoryPascal}Action.{method.MethodName}),");
        }
        sb.AppendLine("                _ => false");
        sb.AppendLine("            };");
        sb.AppendLine("        }");
        sb.AppendLine();
        sb.AppendLine("        private static bool SetAndReturn<T>(out T action, T value)");
        sb.AppendLine("        {");
        sb.AppendLine("            action = value;");
        sb.AppendLine("            return true;");
        sb.AppendLine("        }");
        sb.AppendLine();

        // Generate ToActionString method for this category
        sb.AppendLine("        /// <summary>");
        sb.AppendLine("        /// Converts the action enum to its kebab-case string representation.");
        sb.AppendLine("        /// </summary>");
        sb.AppendLine($"        public static string ToActionString({info.CategoryPascal}Action action)");
        sb.AppendLine("        {");
        sb.AppendLine("            return action switch");
        sb.AppendLine("            {");
        foreach (var method in info.Methods)
        {
            sb.AppendLine($"                {info.CategoryPascal}Action.{method.MethodName} => \"{method.ActionName}\",");
        }
        sb.AppendLine($"                _ => throw new System.ArgumentException($\"Unknown {info.CategoryPascal}Action: {{action}}\")");
        sb.AppendLine("            };");
        sb.AppendLine("        }");
        sb.AppendLine();

        // Generate request DTOs for methods with parameters
        foreach (var method in info.Methods.Where(m => m.Parameters.Count > 0))
        {
            sb.AppendLine($"        /// <summary>Request DTO for {method.ActionName} action</summary>");
            sb.AppendLine($"        public sealed record {method.MethodName}Request(");

            var paramLines = method.Parameters.Select((p, i) =>
            {
                var suffix = i < method.Parameters.Count - 1 ? "," : "";
                if (p.HasDefault)
                {
                    return $"            {p.TypeName} {StringHelper.ToPascalCase(p.Name)} = {p.DefaultValue}{suffix}";
                }
                return $"            {p.TypeName} {StringHelper.ToPascalCase(p.Name)}{suffix}";
            });

            sb.AppendLine(string.Join("\r\n", paramLines));
            sb.AppendLine("        );");
            sb.AppendLine();
        }

        // Generate MCP forward methods
        sb.AppendLine("        // ============================================");
        sb.AppendLine("        // MCP Forward Methods (generated)");
        sb.AppendLine("        // ============================================");
        sb.AppendLine();

        foreach (var method in info.Methods)
        {
            GenerateForwardMethod(sb, info, method);
        }

        // Generate the RouteAction switch
        sb.AppendLine("        /// <summary>");
        sb.AppendLine("        /// Routes an action to the appropriate forward method.");
        sb.AppendLine("        /// </summary>");
        sb.AppendLine($"        public static string RouteAction(");
        sb.AppendLine($"            {info.CategoryPascal}Action action,");
        sb.AppendLine($"            string sessionId,");
        sb.AppendLine($"            System.Func<string, string, object?, string> forwardToService,");

        // Collect all unique exposed parameters across all methods
        var allExposedParams = GetAllExposedParameters(info);
        for (int i = 0; i < allExposedParams.Count; i++)
        {
            var p = allExposedParams[i];
            var comma = i < allExposedParams.Count - 1 ? "," : ")";
            sb.AppendLine($"            {p.TypeName} {p.Name} = {p.DefaultValue ?? "null"}{comma}");
        }

        sb.AppendLine("        {");
        sb.AppendLine("            return action switch");
        sb.AppendLine("            {");
        foreach (var method in info.Methods)
        {
            var forwardArgs = BuildForwardArgs(method, allExposedParams);
            sb.AppendLine($"                {info.CategoryPascal}Action.{method.MethodName} => Forward{method.MethodName}(sessionId, forwardToService{forwardArgs}),");
        }
        sb.AppendLine($"                _ => throw new System.ArgumentException($\"Unknown action: {{action}}\")");
        sb.AppendLine("            };");
        sb.AppendLine("        }");
        sb.AppendLine();

        // Generate CLI RouteCliArgs method
        GenerateCliRouteMethod(sb, info);

        sb.AppendLine("    }");
        sb.AppendLine("}");

        return sb.ToString();
    }

    private static void GenerateCliRouteMethod(StringBuilder sb, ServiceInfo info)
    {
        sb.AppendLine("        // ============================================");
        sb.AppendLine("        // CLI Routing (generated)");
        sb.AppendLine("        // ============================================");
        sb.AppendLine();
        sb.AppendLine("        /// <summary>");
        sb.AppendLine("        /// Builds the args object for a CLI action.");
        sb.AppendLine("        /// Returns (command, args) tuple for sending to service.");
        sb.AppendLine("        /// </summary>");
        sb.AppendLine($"        public static (string Command, object? Args) RouteCliArgs(");
        sb.AppendLine($"            string action,");

        // Collect all unique exposed parameters
        var allExposedParams = GetAllExposedParameters(info);
        for (int i = 0; i < allExposedParams.Count; i++)
        {
            var p = allExposedParams[i];
            var comma = i < allExposedParams.Count - 1 ? "," : ")";
            sb.AppendLine($"            {p.TypeName} {p.Name} = {p.DefaultValue ?? "null"}{comma}");
        }

        sb.AppendLine("        {");
        sb.AppendLine($"            var command = $\"{info.Category}.{{action}}\";");
        sb.AppendLine();

        // Generate switch for building args
        sb.AppendLine("            object? args = action switch");
        sb.AppendLine("            {");

        foreach (var method in info.Methods)
        {
            var argsExpr = BuildCliArgsExpression(method);
            sb.AppendLine($"                \"{method.ActionName}\" => {argsExpr},");
        }

        sb.AppendLine($"                _ => throw new System.ArgumentException($\"Unknown action: {{action}}\")");
        sb.AppendLine("            };");
        sb.AppendLine();
        sb.AppendLine("            return (command, args);");
        sb.AppendLine("        }");
        sb.AppendLine();

        // Generate CLI Settings class
        GenerateCliSettings(sb, info, allExposedParams);

        // Note: CliCommand generation was removed because:
        // - It requires Service reference which Core doesn't have
        // - Conditional compilation (#if EXCELCLI) doesn't work across assemblies
        // - The remaining command boilerplate is minimal (~15 lines)
    }

    private static void GenerateCliSettings(StringBuilder sb, ServiceInfo info, List<ExposedParameter> allParams)
    {
        // Note: These types require Spectre.Console reference in consuming project
        sb.AppendLine("        /// <summary>");
        sb.AppendLine($"        /// Generated CLI settings for {info.CategoryPascal} commands.");
        sb.AppendLine("        /// Requires Spectre.Console package reference.");
        sb.AppendLine("        /// </summary>");
        sb.AppendLine("        public sealed class CliSettings : Spectre.Console.Cli.CommandSettings");
        sb.AppendLine("        {");

        // Action argument (always first)
        sb.AppendLine("            [Spectre.Console.Cli.CommandArgument(0, \"<ACTION>\")]");
        sb.AppendLine("            [System.ComponentModel.Description(\"The action to perform\")]");
        sb.AppendLine("            public string Action { get; init; } = string.Empty;");
        sb.AppendLine();

        // Session ID (always required for session-based tools)
        if (!info.NoSession)
        {
            sb.AppendLine("            [Spectre.Console.Cli.CommandOption(\"-s|--session <SESSION>\")]");
            sb.AppendLine("            [System.ComponentModel.Description(\"Session ID from 'session open' command\")]");
            sb.AppendLine("            public string SessionId { get; init; } = string.Empty;");
            sb.AppendLine();
        }

        // Generate all exposed parameters
        foreach (var p in allParams)
        {
            var optionName = StringHelper.ToKebabCase(p.Name);
            var description = p.Description ?? StringHelper.GetParameterDescription(p.Name);
            var escapedDescription = description.Replace("\"", "\\\"").Replace("\n", " ");
            var valuePlaceholder = p.Name.ToUpperInvariant();

            sb.AppendLine($"            [Spectre.Console.Cli.CommandOption(\"--{optionName} <{valuePlaceholder}>\")]");
            sb.AppendLine($"            [System.ComponentModel.Description(\"{escapedDescription}\")]");
            sb.AppendLine($"            public {p.TypeName} {StringHelper.ToPascalCase(p.Name)} {{ get; init; }}");
            sb.AppendLine();
        }

        sb.AppendLine("        }");
    }

    private static string BuildCliArgsExpression(MethodInfo method)
    {
        if (method.Parameters.Count == 0)
            return "null";

        var props = new List<string>();
        foreach (var p in method.Parameters)
        {
            string valueName;
            if (p.IsFileOrValue)
            {
                // CLI passes the raw param - caller resolves file before calling
                valueName = p.Name;
            }
            else if (p.IsFromString && p.ExposedName != null)
            {
                // CLI passes string directly to service using exposed name
                valueName = p.ExposedName;
            }
            else
            {
                valueName = p.Name;
            }

            // Use ExposedName for JSON property names when FromString specifies alternate name
            var propName = (p.IsFromString && p.ExposedName != null) ? p.ExposedName : p.Name;
            var jsonName = char.ToLowerInvariant(propName[0]) + propName.Substring(1);
            props.Add($"{jsonName} = {valueName}");
        }

        return $"new {{ {string.Join(", ", props)} }}";
    }

    private static void GenerateForwardMethod(StringBuilder sb, ServiceInfo info, MethodInfo method)
    {
        sb.AppendLine($"        /// <summary>Forward method for {method.ActionName} action</summary>");

        // Build parameter list - Core params might need transforms
        var methodParams = new List<string> { "string sessionId", "System.Func<string, string, object?, string> forwardToService" };

        foreach (var p in method.Parameters)
        {
            if (p.IsFileOrValue)
            {
                // Expose both value and file params
                methodParams.Add($"string? {p.Name} = null");
                methodParams.Add($"string? {p.Name}{p.FileSuffix} = null");
            }
            else if (p.IsFromString && p.IsEnum)
            {
                // Expose as string
                var exposedName = p.ExposedName ?? p.Name;
                methodParams.Add($"string? {exposedName} = null");
            }
            else
            {
                // Keep as-is
                var defaultStr = p.HasDefault ? $" = {p.DefaultValue}" : "";
                // Make nullable if not already
                var typeName = p.TypeName.EndsWith("?") ? p.TypeName : $"{p.TypeName}?";
                methodParams.Add($"{typeName} {p.Name}{defaultStr}");
            }
        }

        sb.AppendLine($"        public static string Forward{method.MethodName}({string.Join(", ", methodParams)})");
        sb.AppendLine("        {");

        // Generate validation for required string parameters only
        // RequireNotEmpty only works with string? parameters
        foreach (var p in method.Parameters.Where(p => (p.IsRequired || (!p.HasDefault && !p.TypeName.EndsWith("?"))) && StringHelper.IsStringType(p.TypeName)))
        {
            var paramName = p.IsFromString && p.IsEnum ? (p.ExposedName ?? p.Name) : p.Name;
            sb.AppendLine($"            Sbroenne.ExcelMcp.Core.Utilities.ParameterTransforms.RequireNotEmpty({paramName}, \"{paramName}\", \"{method.ActionName}\");");
        }

        // Generate transforms (only for FileOrValue parameters)
        // Note: FromString enum parameters are passed as-is to the service (service does parsing)
        foreach (var p in method.Parameters)
        {
            if (p.IsFileOrValue)
            {
                sb.AppendLine($"            var resolved{StringHelper.ToPascalCase(p.Name)} = Sbroenne.ExcelMcp.Core.Utilities.ParameterTransforms.ResolveFileOrValue({p.Name}, {p.Name}{p.FileSuffix});");
            }
            // FromString enum parameters: pass raw string to service (no pre-parsing)
        }

        // Build the request object - always use method-specific command constant
        if (method.Parameters.Count == 0)
        {
            sb.AppendLine($"            return forwardToService({method.MethodName}Command, sessionId, null);");
        }
        else
        {
            sb.AppendLine($"            return forwardToService({method.MethodName}Command, sessionId, new");
            sb.AppendLine("            {");
            foreach (var p in method.Parameters)
            {
                string valueExpr;
                if (p.IsFileOrValue)
                {
                    valueExpr = $"resolved{StringHelper.ToPascalCase(p.Name)}";
                }
                else if (p.IsFromString && p.ExposedName != null)
                {
                    // FromString parameters: pass the exposed name (raw string) to service
                    valueExpr = p.ExposedName;
                }
                else
                {
                    valueExpr = p.Name;
                }
                // Use ExposedName for property name when FromString attribute specifies an alternate name
                var propertyName = (p.IsFromString && p.ExposedName != null) ? p.ExposedName : p.Name;
                sb.AppendLine($"                {StringHelper.ToPascalCase(propertyName)} = {valueExpr},");
            }
            sb.AppendLine("            });");
        }

        sb.AppendLine("        }");
        sb.AppendLine();
    }

    private static List<ExposedParameter> GetAllExposedParameters(ServiceInfo info)
    {
        var result = new Dictionary<string, ExposedParameter>(StringComparer.OrdinalIgnoreCase);

        foreach (var method in info.Methods)
        {
            foreach (var p in method.Parameters)
            {
                if (p.IsFileOrValue)
                {
                    // Add both value and file params
                    if (!result.ContainsKey(p.Name))
                        result[p.Name] = new ExposedParameter(p.Name, "string?", p.XmlDocDescription, "null");
                    var fileParamName = $"{p.Name}{p.FileSuffix}";
                    if (!result.ContainsKey(fileParamName))
                        result[fileParamName] = new ExposedParameter(fileParamName, "string?", $"Path to file containing {p.Name}", "null");
                }
                else if (p.IsFromString && p.IsEnum)
                {
                    var exposedName = p.ExposedName ?? p.Name;
                    if (!result.ContainsKey(exposedName))
                        result[exposedName] = new ExposedParameter(exposedName, "string?", p.XmlDocDescription, "null");
                }
                else
                {
                    if (!result.ContainsKey(p.Name))
                    {
                        var typeName = p.TypeName.EndsWith("?") ? p.TypeName : $"{p.TypeName}?";
                        var defaultVal = p.HasDefault ? p.DefaultValue : "null";
                        result[p.Name] = new ExposedParameter(p.Name, typeName, p.XmlDocDescription, defaultVal);
                    }
                }
            }
        }

        return result.Values.ToList();
    }

    private static string BuildForwardArgs(MethodInfo method, List<ExposedParameter> allParams)
    {
        if (method.Parameters.Count == 0)
            return "";

        var args = new List<string>();
        foreach (var p in method.Parameters)
        {
            if (p.IsFileOrValue)
            {
                args.Add(p.Name);
                args.Add($"{p.Name}{p.FileSuffix}");
            }
            else if (p.IsFromString && p.IsEnum)
            {
                args.Add(p.ExposedName ?? p.Name);
            }
            else
            {
                args.Add(p.Name);
            }
        }

        return ", " + string.Join(", ", args);
    }

    private static string GenerateComparisonFile(ServiceInfo info)
    {
        var sb = new StringBuilder();

        sb.AppendLine("// <auto-generated />");
        sb.AppendLine("// This file is for COMPARISON ONLY - shows what the generator produces");
        sb.AppendLine("// Compare against existing manual code to validate generation is correct");
        sb.AppendLine();
        sb.AppendLine($"/*");
        sb.AppendLine($"GENERATED FROM: I{info.CategoryPascal}Commands");
        sb.AppendLine($"CATEGORY: {info.Category}");
        sb.AppendLine($"MCP TOOL: {info.McpToolName}");
        sb.AppendLine($"REQUIRES SESSION: {!info.NoSession}");
        sb.AppendLine();
        sb.AppendLine("METHODS:");

        foreach (var method in info.Methods)
        {
            sb.AppendLine($"  {method.MethodName}()");
            sb.AppendLine($"    -> action: \"{method.ActionName}\"");
            sb.AppendLine($"    -> command: \"{info.Category}.{method.ActionName}\"");
            sb.AppendLine($"    -> returns: {method.ReturnType}");
            if (method.Parameters.Count > 0)
            {
                sb.AppendLine($"    -> params:");
                foreach (var p in method.Parameters)
                {
                    var defaultStr = p.HasDefault ? $" = {p.DefaultValue}" : "";
                    sb.AppendLine($"         {p.TypeName} {p.Name}{defaultStr}");
                }
            }
            sb.AppendLine();
        }

        sb.AppendLine("EXPECTED MCP SWITCH CASES:");
        foreach (var method in info.Methods)
        {
            var enumValue = method.MethodName;
            if (method.Parameters.Count > 0)
            {
                sb.AppendLine($"  PowerQueryAction.{enumValue} => Forward{method.MethodName}(sessionId, ...),");
            }
            else
            {
                sb.AppendLine($"  PowerQueryAction.{enumValue} => ExcelToolsBase.ForwardToService(\"{info.Category}.{method.ActionName}\", sessionId),");
            }
        }
        sb.AppendLine();

        sb.AppendLine("EXPECTED CLI ARGS MAPPING:");
        foreach (var method in info.Methods)
        {
            if (method.Parameters.Count > 0)
            {
                var args = string.Join(", ", method.Parameters.Select(p => $"{p.Name} = settings.{StringHelper.ToPascalCase(p.Name)}"));
                sb.AppendLine($"  \"{method.ActionName}\" => new {{ {args} }},");
            }
            else
            {
                sb.AppendLine($"  \"{method.ActionName}\" => null,");
            }
        }

        sb.AppendLine("*/");

        return sb.ToString();
    }

    // NOTE: Data models (ServiceInfo, MethodInfo, ParameterInfo) are now in
    // ExcelMcp.Generators.Shared and included as source files
}
