using System.Collections.Immutable;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using Sbroenne.ExcelMcp.Generators.Common;

namespace Sbroenne.ExcelMcp.Generators.Mcp;

/// <summary>
/// Generates MCP Tool classes with [McpServerTool] attributes
/// from Core command interfaces marked with [ServiceCategory].
/// </summary>
[Generator]
public class McpToolGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Find all interfaces with [ServiceCategory] attribute
        var interfaceDeclarations = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (s, _) => SyntaxHelper.IsInterfaceWithAttributes(s),
                transform: static (ctx, _) => SyntaxHelper.GetServiceInterfaceOrNull(ctx))
            .Where(static m => m is not null);

        // Combine with compilation
        var compilationAndInterfaces = context.CompilationProvider.Combine(interfaceDeclarations.Collect());

        // Generate source
        context.RegisterSourceOutput(compilationAndInterfaces,
            static (spc, source) => Execute(source.Left, source.Right!, spc));
    }

    private static void Execute(Compilation compilation, ImmutableArray<InterfaceDeclarationSyntax?> interfaces, SourceProductionContext context)
    {
        if (interfaces.IsDefaultOrEmpty)
            return;

        var distinctInterfaces = interfaces
            .Where(i => i is not null)
            .Cast<InterfaceDeclarationSyntax>()
            .Distinct()
            .ToList();

        if (distinctInterfaces.Count == 0)
            return;

        foreach (var interfaceDecl in distinctInterfaces)
        {
            var model = compilation.GetSemanticModel(interfaceDecl.SyntaxTree);
            var interfaceSymbol = model.GetDeclaredSymbol(interfaceDecl) as INamedTypeSymbol;

            if (interfaceSymbol is null)
                continue;

            var info = ServiceInfoExtractor.ExtractServiceInfo(interfaceSymbol);
            if (info is null)
                continue;

            // Generate MCP Tool for this category
            var toolCode = GenerateMcpTool(info);
            context.AddSource($"McpTool.{info.CategoryPascal}.g.cs", SourceText.From(toolCode, Encoding.UTF8));
        }
    }

    private static string GenerateMcpTool(ServiceInfo info)
    {
        var sb = new StringBuilder();

        sb.AppendLine("// <auto-generated />");
        sb.AppendLine("#nullable enable");
        sb.AppendLine("#pragma warning disable CS1591 // Missing XML comment");
        sb.AppendLine();
        sb.AppendLine("using System.Text.Json;");
        sb.AppendLine("using ModelContextProtocol.Server;");
        sb.AppendLine("using Sbroenne.ExcelMcp.Generated;");
        sb.AppendLine();
        sb.AppendLine("namespace Sbroenne.ExcelMcp.McpServer.Generated;");
        sb.AppendLine();
        sb.AppendLine("/// <summary>");
        sb.AppendLine($"/// Generated MCP tool for {info.CategoryPascal} operations.");
        sb.AppendLine("/// </summary>");
        sb.AppendLine($"public static class Excel{info.CategoryPascal}Tool");
        sb.AppendLine("{");

        // Generate the main tool method with all parameters
        GenerateToolMethod(sb, info);

        sb.AppendLine("}");

        return sb.ToString();
    }

    private static void GenerateToolMethod(StringBuilder sb, ServiceInfo info)
    {
        var allParams = ServiceInfoExtractor.GetAllExposedParameters(info);

        // Build parameter list for tool method
        var toolParams = new List<string>();
        toolParams.Add($"[System.ComponentModel.Description(\"Action to perform\")] {info.CategoryPascal}Action action");

        if (!info.NoSession)
        {
            toolParams.Add("[System.ComponentModel.Description(\"Session ID\")] string sessionId");
        }

        foreach (var p in allParams)
        {
            var description = p.Description ?? StringHelper.GetParameterDescription(p.Name);
            toolParams.Add($"[System.ComponentModel.Description(\"{EscapeString(description)}\")] {p.TypeName} {p.Name} = default");
        }

        // Generate the tool method with rich description from interface XML docs
        var toolDescription = EscapeString(info.XmlDocSummary ?? $"{info.CategoryPascal} operations.");
        sb.AppendLine("    /// <summary>");
        sb.AppendLine($"    /// {toolDescription}");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    [McpServerTool]");
        sb.AppendLine($"    public static async Task<string> Excel{info.CategoryPascal}(");

        for (int i = 0; i < toolParams.Count; i++)
        {
            var comma = i < toolParams.Count - 1 ? "," : ")";
            sb.AppendLine($"        {toolParams[i]}{comma}");
        }

        sb.AppendLine("    {");

        // Route to the appropriate action
        sb.AppendLine($"        return ServiceRegistry.{info.CategoryPascal}.RouteAction(");
        sb.AppendLine("            action,");
        sb.AppendLine("            ExcelToolsBase.ForwardToService,");

        if (!info.NoSession)
        {
            sb.AppendLine("            sessionId,");
        }

        for (int i = 0; i < allParams.Count; i++)
        {
            var p = allParams[i];
            var comma = i < allParams.Count - 1 ? "," : ");";
            sb.AppendLine($"            {p.Name}{comma}");
        }

        sb.AppendLine("    }");
    }

    private static string EscapeString(string value)
    {
        return value.Replace("\"", "\\\"").Replace("\n", " ").Replace("\r", "");
    }
}
